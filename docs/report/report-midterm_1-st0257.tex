% !BIB TS-program = biber

\documentclass[11pt,letterpaper,oneside]{article}

\input{preamble/setup}

\begin{document}

\input{preamble/title}

% ------------------------------
% Contents
\tableofcontents

% Only print list of figures if we have included any.
\iftotalfigures
    \listoffigures
\fi

% \listoftables

\clearpage

% ------------------------------
% Main sections (as required)

\section{Context and Approach}

This project focuses on handling large datasets in C/C++ on Linux and evaluating
how different design choices affect performance. The main objectives are:
\begin{itemize}
    \item Generate and process datasets with millions of records.
    \item Compare using \textbf{values vs. pointers} to measure memory savings
    and runtime performance.
    \item Compare using \textbf{structs (C)} vs. \textbf{classes (C++)} to
    examine efficiency and memory layout.
    \item Record \textbf{execution time} and \textbf{memory usage} for each
    query with a custom \texttt{monitor}.
\end{itemize}

Each record contains: full name, date of birth, city of residence, assets,
debts, ID number, and the assigned tax calendar group (A/B/C) based on the last
digits of the ID.

\section{Queries}

The required queries were:
\begin{enumerate}
    \item \textbf{Oldest person}
    \begin{itemize}
        \item Across the entire dataset.
        \item Grouped by city.
    \end{itemize}
    \item \textbf{Person with the most assets}
    \begin{itemize}
        \item Overall.
        \item By city.
        \item By tax calendar group (A/B/C).
    \end{itemize}
    \item \textbf{Tax filers}
    \begin{itemize}
        \item Count people in each tax calendar group.
        \item Validate assignment according to ID termination rules.
    \end{itemize}
\end{enumerate}

Additional queries designed by the team:
\begin{enumerate}
    \item Cities with the highest average assets.
    \item Percentage of people older than 80 in each tax group.
    \item Number of people in each city.
\end{enumerate}

\section{How We Measured Performance}

Two main configurations were tested:
\begin{itemize}
    \item \textbf{By value vs. by pointer:} storing full records directly
    compared to storing only pointers to them.
    \item \textbf{Struct vs. class:} using plain structs without constructors or
    virtual methods compared to full C++ classes with methods.
\end{itemize}

Performance was measured through:
\begin{itemize}
    \item \textbf{Execution time} with \texttt{std::chrono}.
    \item \textbf{Memory usage} (RSS in KB) from \texttt{/proc/self/statm}.
    \item \textbf{Recorded statistics} saved by the \texttt{monitor}, summarized
    in console and exported to CSV.
\end{itemize}

\section{Analysis}

The results let us compare time and memory consumption across different
approaches. Key points for analysis include:
\begin{itemize}
    \item The extent of memory savings when using pointers instead of values,
    particularly with very large datasets.
    \item Whether structs offer measurable cache benefits compared to classes.
    \item How queries scale when the dataset grows beyond one million records.
    \item Which queries are more costly in terms of performance, such as full
    scans versus grouped lookups.
\end{itemize}

\section{Preliminary Results}

We collected measurements for dataset creation and several queries using two
main distinctions:
\begin{enumerate}
    \item \textbf{Values vs. Pointers} — how data is stored and accessed.
    \item \textbf{Structs vs. Classes} — how records are defined in C/C++.
\end{enumerate}

The metrics include execution time (milliseconds) and additional memory used
(KB).

\subsection{Dataset Creation}

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Configuration} & \textbf{Time (ms)} & \textbf{Memory (KB)} \\
\hline
Pointers & 1806.87 & 105200 \\
Values   & 1843.18 & 105112 \\
\hline
\end{tabular}
\caption{Time and memory for creating a dataset with 1,000,000 records}
\end{table}

At the dataset creation stage, the use of structs versus classes did not show a
significant difference. Both approaches required roughly the same memory
footprint and initialization time. The small variations are more related to
pointer vs. value than to the record type.

\subsection{Finding Oldest Person (by City)}

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Configuration} & \textbf{Time (ms)} & \textbf{Memory (KB)} \\
\hline
Pointers & 0.056 & 0 \\
Values   & 703.745 & 6972 \\
\hline
\end{tabular}
\caption{Performance of query: oldest person by city}
\end{table}

Here the gap is striking: with pointers the query is almost instantaneous, while
with values it takes hundreds of milliseconds and uses noticeable extra memory.
In this type of traversal, structs behave similarly to classes, but classes may
add small overhead due to constructors and possible alignment padding. Still,
the main bottleneck here is clearly value vs. pointer.

\subsection{Finding Person with Highest Assets (by Tax Group)}

\begin{table}[h!]
\centering
\begin{tabular}{|l|c|c|}
\hline
\textbf{Configuration} & \textbf{Time (ms)} & \textbf{Memory (KB)} \\
\hline
Values   & 92.256 & 0 \\
Pointers & 0.003 & 0 \\
\hline
\end{tabular}
\caption{Performance of query: highest assets by tax group}
\end{table}

In this aggregation query, using pointers again proved much faster. Memory
impact was negligible in both cases. When comparing structs and classes, structs
offer slightly better cache locality (plain old data layout), while classes
bring organizational clarity at the cost of small construction overhead.

\section{Notes on Early Observations}

\begin{itemize}
    \item Dataset creation showed minimal differences across all approaches —
    the choice between struct or class does not matter much here.
    \item Query performance, however, is dominated by whether pointers or values
    are used. Pointers give far superior execution times and avoid unnecessary
    memory copies.
    \item Structs generally help in memory layout and cache efficiency, but when
    queries involve heavy scanning or grouping, the pointer vs. value decision
    outweighs the struct vs. class effect.
\end{itemize}

In summary, structs and classes perform similarly for bulk dataset creation, but
pointers versus values make a dramatic difference when running queries on large
datasets.


\section{Critical Thinking Questions}

\subsection{Why do pointers reduce memory usage when dealing with 10 million records?}

Pointers reduce memory usage because they reference a shared memory location
instead of duplicating entire data structures. In scenarios with millions of
records, storing full copies of the same or large objects is inefficient. By
storing pointers, only the address of the data (typically 4 or 8 bytes,
depending on architecture) is maintained, avoiding redundant copies. This can
drastically reduce memory consumption, though the actual savings depend on the
structure size and whether the pointed-to data is reused.

\subsection{If the Calendar depends on the person's ID, how can group searches be optimized?}

If the calendar grouping is a deterministic function of the person’s ID, it is
unnecessary to store the group explicitly for each record. Instead, one can
precompute or derive the mapping function between the ID and the calendar group
(e.g., an enumeration such as \texttt{CalendarTaxGroup}). By indexing or hashing
IDs directly to their groups, searches can be optimized, reducing both memory
overhead and lookup time.

\subsection{How does memory access differ between an array of structs and a vector of class objects?}

The distinction arises primarily from data layout and object semantics:

\begin{itemize}
    \item \textbf{Array of Structs (AoS):} Structs that are Plain Old Data (POD)
    types—meaning no user-defined constructors, destructors, or virtual
    functions—are stored contiguously in memory. This layout maximizes spatial
    locality and cache efficiency, which is advantageous in data-oriented
    design.
    \item \textbf{Vector of Class Objects:} While \texttt{std::vector} also
    stores elements contiguously, class objects often introduce overhead through
    constructors, destructors, and possible virtual table pointers. This makes
    them heavier than plain structs, potentially harming cache performance. If
    the class holds pointers to heap-allocated members, memory access becomes
    indirect and fragmented.
\end{itemize}

Thus, for performance-critical workloads requiring sequential traversal and
predictable memory access, an AoS layout is typically more efficient.

\subsection{How can \texttt{mmap} or virtual memory help when data exceeds
physical RAM?}

When datasets exceed available RAM, the operating system leverages virtual
memory. Pages that cannot fit in RAM are stored in a swap area on disk, with the
OS transparently paging them in and out. This allows programs to operate on data
larger than physical memory, though with significant latency penalties due to
disk access times.

The \texttt{mmap} system call provides more direct control. It can:

\begin{itemize}
    \item Map files directly into memory space, enabling efficient I/O by
    allowing the OS page cache to handle reads and writes.
    \item Allocate large contiguous memory regions, bypassing some limitations
    of \texttt{malloc}.
    \item Enable shared memory between processes by mapping the same file or
    anonymous memory region into multiple address spaces.
\end{itemize}

In high-volume data processing, combining virtual memory and \texttt{mmap} can
allow applications to handle datasets that far exceed the machine’s physical
memory capacity, though at the cost of higher latency for non-resident pages.


% ------------------------------
% Bibliography
\printbibliography

\end{document}
