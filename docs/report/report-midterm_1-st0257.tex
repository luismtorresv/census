% !BIB TS-program = biber

\documentclass[11pt,letterpaper,oneside]{article}

\input{preamble/setup}

\begin{document}

\input{preamble/title}

% ------------------------------
% Contents
\tableofcontents

% Only print list of figures if we have included any.
\iftotalfigures
    \listoffigures
\fi

\listoftables

\clearpage

% ------------------------------
% Main sections (as required)

\section{Context and Approach}

This project focuses on handling large datasets in C/C++ on Linux and evaluating
how different design choices affect performance. The main objectives are:
\begin{itemize}
    \item Generate and process datasets with millions of records.
    \item Compare using \textbf{values vs. pointers} to measure memory savings
    and runtime performance.
    \item Compare using \textbf{structs (C)} vs. \textbf{classes (C++)} to
    examine efficiency and memory layout.
    \item Record \textbf{execution time} and \textbf{memory usage} for each
    query with a custom \texttt{monitor}.
\end{itemize}

Each record contains: full name, date of birth, city of residence, assets,
debts, ID number, and the assigned tax calendar group (A/B/C) based on the last
digits of the ID.

\section{Queries}

The required queries were:
\begin{enumerate}
    \item \textbf{Oldest person}
    \begin{itemize}
        \item Across the entire dataset.
        \item Grouped by city.
    \end{itemize}
    \item \textbf{Person with the most assets}
    \begin{itemize}
        \item Overall.
        \item By city.
        \item By tax calendar group (A/B/C).
    \end{itemize}
    \item \textbf{Tax filers}
    \begin{itemize}
        \item Count people in each tax calendar group.
        \item Validate assignment according to ID termination rules.
    \end{itemize}
\end{enumerate}

Additional queries designed by the team:
\begin{enumerate}
    \item Cities with the highest average assets.
    \item Percentage of people older than 80 in each tax group.
    \item Number of people in each city.
\end{enumerate}

\section{How We Measured Performance}

Two main configurations were tested:
\begin{itemize}
    \item \textbf{By value vs. by pointer:} storing full records directly
    compared to storing only pointers to them.
    \item \textbf{\texttt{struct} vs. \texttt{class}:} using plain structs
    without constructors or virtual methods compared to full C++ classes with
    methods.
\end{itemize}

Performance was measured through:
\begin{itemize}
    \item \textbf{Execution time} with \texttt{std::chrono}.
    \item \textbf{Memory usage} (RSS in KB) from \texttt{/proc/self/statm}.
    \item \textbf{Recorded statistics} saved by the \texttt{monitor} and
    summarized in console.
\end{itemize}

\section{Analysis}

The results allow us to compare execution time and memory consumption across two
main axes:
\begin{enumerate}
    \item \textbf{Value vs. Pointer} --- how records are stored and accessed.
    \item \textbf{\texttt{struct} vs. \texttt{class}} --- how records are
    defined in C/C++.
\end{enumerate}

We ran four representative queries:
\begin{itemize}
    \item Oldest person countrywide.
    \item Person with highest assets overall.
    \item Count people per tax calendar group.
    \item Cities with the highest average assets (one additional query).
\end{itemize}

Each query was executed under both storage modes (value and pointer) and with
both record definitions (\texttt{struct} and \texttt{class}), for a total of 16
comparisons.

\subsection{\texttt{class}-based Records}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|c|}
\hline
\textbf{Query} & \textbf{Mode} & \textbf{Time (ms)} & \textbf{Memory (KB)} \\
\hline
Oldest person (countrywide) & Value   & 328.069 & 6948 \\
                            & Pointer & 15.814  & 0    \\
\hline
Highest assets (overall)    & Value   & 328.628 & 6992 \\
                            & Pointer & 15.567  & 0    \\
\hline
Count by tax group          & Value   & 417.419 & 6804 \\
                            & Pointer & 99.432  & 0    \\
\hline
Average assets (cities)     & Value   & 151.271 & 0    \\
                            & Pointer & 147.434 & 0    \\
\hline
\end{tabular}
\caption{Performance of four queries using class-based records}
\end{table}

\subsection{\texttt{struct}-based Records}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Query} & \textbf{Mode} & \textbf{Time (ms)} & \textbf{Memory (KB)} \\
\hline
Oldest person (countrywide) & Value   & 294.506 & 7012 \\
                            & Pointer & 12.566  & 0    \\
\hline
Highest assets (overall)    & Value   & 296.899 & 7040 \\
                            & Pointer & 11.174  & 0    \\
\hline
Count by tax group          & Value   & 389.490 & 6952 \\
                            & Pointer & 98.951  & 0    \\
\hline
Average assets (cities)     & Value   & 148.053 & 0    \\
                            & Pointer & 143.120 & 0    \\
\hline
\end{tabular}
\caption{Performance of four queries using \texttt{struct}-based records}
\end{table}

\subsection{Observations}

\begin{itemize}
    \item The biggest factor is still \textbf{pointer vs. value}. For both
    \texttt{class} and \texttt{struct} definitions, pointer-based queries are
    consistently faster and avoid additional memory allocations.
    \item \textbf{Structs vs. classes} show similar numbers overall. Structs are
    slightly faster in some queries (e.g., oldest person, highest assets), which
    matches expectations due to simpler layout and no constructor overhead.
    \item The additional query \textit{average assets per city} is relatively
    balanced. Both value and pointer versions run in similar time because this
    query is aggregation-heavy, not copy-heavy.
    \item Memory usage with value storage is consistently higher (6–7 MB extra)
    regardless of record type, while pointer storage incurs negligible extra
    cost.
\end{itemize}

In summary, pointer-based datasets dominate in query performance for both
\texttt{struct} and \texttt{class} records, while \texttt{struct} definitions
offer a small advantage in raw execution time. The main tradeoff lies in code
organization (classes) versus raw efficiency (structs).



\section{Critical Thinking Questions}

\subsection{Why do pointers reduce memory usage when dealing with 10 million records?}

Pointers reduce memory usage because they reference a shared memory location
instead of duplicating entire data structures. In scenarios with millions of
records, storing full copies of the same or large objects is inefficient. By
storing pointers, only the address of the data (typically 4 or 8 bytes,
depending on architecture) is maintained, avoiding redundant copies. This can
drastically reduce memory consumption, though the actual savings depend on the
structure size and whether the pointed-to data is reused.

\subsection{If the Calendar depends on the person's ID, how can group searches be optimized?}

If the calendar grouping is a deterministic function of the person’s ID, it is
unnecessary to store the group explicitly for each record. Instead, one can
precompute or derive the mapping function between the ID and the calendar group
(e.g., an enumeration such as \texttt{CalendarTaxGroup}). By indexing or hashing
IDs directly to their groups, searches can be optimized, reducing both memory
overhead and lookup time.

\subsection{How does memory access differ between an array of structs and a vector of class objects?}

The distinction arises primarily from data layout and object semantics:

\begin{itemize}
    \item \textbf{Array of Structs (AoS):} Structs that are Plain Old Data (POD)
    types—meaning no user-defined constructors, destructors, or virtual
    functions—are stored contiguously in memory. This layout maximizes spatial
    locality and cache efficiency, which is advantageous in data-oriented
    design.
    \item \textbf{Vector of Class Objects:} While \texttt{std::vector} also
    stores elements contiguously, class objects often introduce overhead through
    constructors, destructors, and possible virtual table pointers. This makes
    them heavier than plain structs, potentially harming cache performance. If
    the class holds pointers to heap-allocated members, memory access becomes
    indirect and fragmented.
\end{itemize}

Thus, for performance-critical workloads requiring sequential traversal and
predictable memory access, an AoS layout is typically more efficient.

\subsection{How can \texttt{mmap} or virtual memory help when data exceeds
physical RAM?}

When datasets exceed available RAM, the operating system leverages virtual
memory. Pages that cannot fit in RAM are stored in a swap area on disk, with the
OS transparently paging them in and out. This allows programs to operate on data
larger than physical memory, though with significant latency penalties due to
disk access times.

The \texttt{mmap} system call provides more direct control. It can:

\begin{itemize}
    \item Map files directly into memory space, enabling efficient I/O by
    allowing the OS page cache to handle reads and writes.
    \item Allocate large contiguous memory regions, bypassing some limitations
    of \texttt{malloc}.
    \item Enable shared memory between processes by mapping the same file or
    anonymous memory region into multiple address spaces.
\end{itemize}

In high-volume data processing, combining virtual memory and \texttt{mmap} can
allow applications to handle datasets that far exceed the machine’s physical
memory capacity, though at the cost of higher latency for non-resident pages.

\section*{Addendum: \texttt{struct} vs. \texttt{class} in C++}

In the context of C++, the distinction between \texttt{struct} and
\texttt{class} is almost entirely syntactic. Both declare a class type, share
the same object model, and support the same features (constructors, destructors,
inheritance, templates, operator overloading, virtual functions, etc.).

The only formal difference is the default access level:
\begin{itemize}
    \item In a \texttt{struct}, members and base classes are \textbf{public} by
    default.
    \item In a \texttt{class}, members and base classes are \textbf{private} by
    default.
\end{itemize}

This is consistently stated across references:
\begin{itemize}
    \item Stroustrup (The Design and Evolution of C++): both keywords map to the
    same underlying concept, introduced to allow a smooth transition from
    C-style structures to fully featured C++ classes.
    \item The C++ Programming Language (2013): a struct is a class with public
    members by default.
    \item Microsoft, IBM, Siemens documentation: same behavior, only default
    visibility differs.
    \item Stack Overflow discussions emphasize that the choice is purely
    stylistic and has no impact on generated code.
\end{itemize}

In practice:
\begin{itemize}
    \item Many developers use \texttt{struct} for plain data aggregates (POD
    types) without significant encapsulation.
    \item \texttt{class} is often preferred for abstractions with private data
    and member functions.
\end{itemize}

This conclusion is consistent across references including Stroustrup, Microsoft,
IBM, Siemens, and Stack Overflow discussions. In practice, developers often use
\texttt{struct} for plain aggregates (POD types) and \texttt{class} for
abstractions with encapsulation, but the compiler treats them identically apart
from default visibility.

To confirm this, we compared the generated binaries of both versions of the
program using \texttt{elf\_diff} (v0.7.1). The results show no significant
differences:

\begin{lstlisting}[caption={\texttt{elf\_diff} comparison of binaries built with \texttt{class} vs. \texttt{struct}}]
Statistics of elf_diff comparison of files
    old: build/census-class
    new: build/census-struct

Difference in resource consumption:
    code:        0 bytes
    text:        0 bytes
    data:        0 bytes
    static ram:  0 bytes
    bss:         0 bytes

Symbol statistics:
    old:         1636
    new:         1636
    persisting:  1636
    disappeared: 0
    appeared:    0
    similar:     0
    migrated:    0

No significant differences.
\end{lstlisting}

This confirms empirically that the choice between \texttt{struct} and
\texttt{class} has no effect on the generated machine code or resource usage,
supporting the claim that the distinction is purely about default visibility and
coding style.

For the experiments in this project, both forms compile down to the same
representation and execution performance. Any differences observed in the
results come from measurement noise, not from the keyword itself. What matters
for performance is whether we use pointers or values, not whether the record is
declared with \texttt{struct} or \texttt{class}.


% ------------------------------
% Bibliography
\printbibliography

\end{document}
